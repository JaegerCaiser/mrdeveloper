---
title: "A Saga do CI/CD: Como Corrigimos uma Race Condition no GitHub Actions"
publishedAt: "2025-11-06"
summary: "Uma hist√≥ria real de depura√ß√£o de um workflow de CI/CD, onde a concorr√™ncia de gatilhos e a ordem de execu√ß√£o causaram uma falha sutil, mas cr√≠tica, no nosso processo de release."
---

Todo desenvolvedor que j√° configurou um pipeline de CI/CD conhece a sensa√ß√£o: a satisfa√ß√£o de ver os checks verdes e a automa√ß√£o funcionando... e a frustra√ß√£o profunda quando uma falha misteriosa acontece. Recentemente, passei por uma dessas sagas ao tentar otimizar os workflows de um projeto, e a jornada para encontrar a solu√ß√£o foi cheia de li√ß√µes valiosas.

## O Problema Inicial: Workflows Lentos e Redundantes

Tudo come√ßou com um objetivo simples: fazer nossos workflows rodarem mais r√°pido. Em Pull Requests que alteravam apenas a documenta√ß√£o (arquivos `.md`), nossos jobs de teste, lint e deploy eram executados desnecessariamente, gastando tempo e recursos.

A solu√ß√£o parecia √≥bvia: usar um filtro de caminho para pular os jobs se nenhuma altera√ß√£o no c√≥digo fosse detectada.

## A Primeira Tentativa e o Primeiro Erro

Implementamos a popular action `dorny/paths-filter`. A ideia era simples: se os arquivos alterados n√£o estivessem em `src/`, `package.json`, etc., os steps seguintes seriam pulados.

```yaml
- name: Check for code changes
  id: filter
  uses: dorny/paths-filter@v3
  with:
    filters: |
      code:
        - 'src/**'
        - '.github/workflows/**'
        # ... outros caminhos

- name: Install dependencies
  if: steps.filter.outputs.code == 'true'
  run: pnpm install
```

**Onde quebrou?** O workflow falhou com um erro enigm√°tico: `Error: Can't find common ancestor`.

- **Li√ß√£o 1: O `fetch-depth` √© Crucial.** A action `actions/checkout` por padr√£o faz um checkout "superficial" (`fetch-depth: 1`), baixando apenas o √∫ltimo commit. O `paths-filter` precisa do hist√≥rico completo para comparar a branch do PR com a branch base. A solu√ß√£o foi adicionar `fetch-depth: 0` ao checkout.

## O Segundo Erro: A Duplicidade de Deployments

Com o primeiro erro corrigido, notamos que cada PR criava **duas** entradas de deployment: uma atribu√≠da a mim e outra ao bot `github-actions[bot]`.

- **Li√ß√£o 2: `environment:` Nativo vs. Actions Manuais.** Descobrimos que est√°vamos usando dois mecanismos para o mesmo fim. A chave `environment:` no nosso job j√° instru√≠a o GitHub a criar um deployment (atribu√≠do ao usu√°rio que iniciou o workflow). Ao mesmo tempo, a action `bobheadxi/deployments` tamb√©m criava um deployment (atribu√≠do ao bot). A solu√ß√£o foi remover a action e confiar 100% no mecanismo nativo do GitHub, que hoje j√° √© robusto o suficiente para gerenciar o ciclo de vida completo do deployment.

## O Furo Final: A Race Condition

Tudo parecia perfeito, at√© que uma an√°lise mais profunda revelou uma falha cr√≠tica. Nosso workflow `preview.yml` era acionado por dois eventos: `push` em branches `release/*` e `pull_request`.

O objetivo era:

1. No `push` para `release/*`, criar uma tag beta com `semantic-release`.
2. No `pull_request`, apenas rodar testes e gerar um preview.

O problema era a `concurrency: cancel-in-progress: true`.

- **A Race Condition:** Quando um desenvolvedor fazia o push da branch de release e abria o PR em seguida, duas execu√ß√µes do workflow eram disparadas. A `concurrency` cancelava a mais antiga (a do `push`), e a execu√ß√£o do `pull_request` continuava. Como o `semantic-release` s√≥ rodava no evento de `push`, a tag beta **nunca era criada**.

- **Li√ß√£o 3: Separe as Responsabilidades.** Um workflow n√£o deve tentar servir a dois mestres. A solu√ß√£o foi dividir o `preview.yml` em dois:
  1. **`preview.yml`:** Focado apenas em valida√ß√£o de PRs (gatilho `pull_request`).
  2. **`create-beta-release.yml`:** Focado apenas em criar a release beta (gatilho `push`).

Essa separa√ß√£o eliminou a competi√ß√£o entre os gatilhos e a race condition, garantindo que cada processo rode de forma confi√°vel e independente.

## O Cap√≠tulo Final: A Otimiza√ß√£o Condicional

Mas a saga n√£o acabou a√≠. Ap√≥s resolver a race condition, percebemos que nossa arquitetura ainda tinha uma falha fundamental: **os status checks ficavam inconsistentes**.

### O Dilema dos Status Checks

Quando implementamos o paths-filter no `preview.yml`, o job `deploy-preview` era completamente **pulados** quando n√£o havia mudan√ßas no c√≥digo. Isso fazia com que os status checks aparecessem como "skipped" em vez de "success", quebrando a consist√™ncia dos required status checks.

```yaml
# ‚ùå ANTES: Job pulado completamente
deploy-preview:
  if: needs.test-and-lint.outputs.code-changed == 'true'  # ‚Üê Isso fazia o job ser skipped
  uses: ./.github/workflows/reusable-deploy-vercel.yml
```

### A Solu√ß√£o Arquitetural

A resposta estava em mover o controle **para dentro** dos reusable workflows. Em vez de decidir no n√≠vel do job se rodar ou n√£o, deixar os reusable workflows decidirem internamente quais steps executar.

```yaml
# ‚úÖ DEPOIS: Job sempre roda, controle interno
deploy-preview:
  # Sem condi√ß√£o no job - sempre roda para status check consistente
  uses: ./.github/workflows/reusable-deploy-vercel.yml
```

Dentro do `reusable-deploy-vercel.yml`, adicionamos o paths-filter e condi√ß√µes em todos os steps:

```yaml
jobs:
  deploy:
    steps:
      - name: Check for code changes
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            code:
              - 'src/**'
              - 'public/**'
              - 'package.json'
              # ... outros arquivos de c√≥digo

      - name: Install Vercel CLI
        if: steps.filter.outputs.code == 'true'  # ‚Üê Condi√ß√£o no step
        run: npm install --global vercel@latest

      - name: Build Project Artifacts
        if: steps.filter.outputs.code == 'true'  # ‚Üê Condi√ß√£o no step
        run: vercel build

      - name: Deploy to Vercel
        if: steps.filter.outputs.code == 'true'  # ‚Üê Condi√ß√£o no step
        run: vercel deploy
```

### O Resultado Perfeito

Agora ambos os reusable workflows seguem o **mesmo padr√£o arquitetural**:

- **`reusable-test-and-lint.yml`**: Paths-filter + steps condicionais
- **`reusable-deploy-vercel.yml`**: Paths-filter + steps condicionais

**Comportamento final:**
- **PRs com mudan√ßas no c√≥digo**: Jobs rodam e fazem trabalho real ‚úÖ
- **PRs s√≥ com documenta√ß√£o**: Jobs rodam (status checks verdes) mas pulam steps internos ‚úÖ

**Benef√≠cios alcan√ßados:**
- ‚úÖ **Status checks consistentes** (sempre success)
- üí∞ **Otimiza√ß√£o de custos** (deploy condicional no Vercel)
- üîÑ **Arquitetura uniforme** nos reusable workflows
- üìã **Compat√≠vel com required status checks**

## Conclus√£o

O que come√ßou como uma simples otimiza√ß√£o se tornou uma jornada profunda pela arquitetura do GitHub Actions. A li√ß√£o final √© clara: workflows de CI/CD s√£o parte do c√≥digo e merecem a mesma aten√ß√£o √† arquitetura, separa√ß√£o de responsabilidades e depura√ß√£o que aplicamos √† nossa aplica√ß√£o.

**Nunca subestime:**
- A import√¢ncia de um bom `fetch-depth`
- O poder das race conditions em sistemas concorrentes
- A necessidade de status checks consistentes
- A beleza de uma arquitetura uniforme

E lembre-se: em CI/CD, assim como na vida, **separar responsabilidades** √© sempre a melhor solu√ß√£o! üöÄ

---

\*Escrito com ‚ù§Ô∏è por **Matheus Caiser, The Mr. Developer\***
